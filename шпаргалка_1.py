''''Шпаргалка с разными типами данных'''

number_1 = 13  # создали переменную с именем number_1  и передали в нее число
number_2 = int(input("введите число "))  # ввели число с клавиатуры (считали символ и обработали его функцией int)
str_1 = "Hello World!"  # создали переменную и передали в нее текст
str_2 = input("Введите строку ")  # ввели строку с клавиатуры

number_3 = number_1 - number_2  # обратились к переменным по названиям, разницу лежащих в переменных данных положили в новую переменную
number_1 += number_2  # то же, что и (number_1 = number_1 + number_2), питон любит все укорачивать)
# в данном варианте мы просим питон сложить все, что есть в первой переменной, с тем, что мы написали после +=, и положить обратно.
# есть куча других операций: * - умножение, / - деление, // - целая часть деления, % - остаток от деления, ** - возведение в степень


print(number_1, number_2, str_1, str_2)  # вывели все значения переменных в консоль (место, где видно все, что мы выводим)
str_2 += str(number_2)  # сделали число строкой с помощью функции str и сложением двух строк приклеили это число к другой строке
print(str_1 + str_2)  # вывели содержимое двух строк, передварительно склеив их

list_1 = ["a", "b", "c", ]  # создали список из 3 элементов-строк (можно любые данные сюда)
list_2 = list(str_1)  # создали список из строки, разделив ее по буквам
list_1.append(input()) # добавили в конец списка новый элемент с клавиатуры
print(list_1)  # вывели список
print(*list_2)  # вывели список красиво
print(list_2[1])  # обратились ко второму элементу списка и вывели его (не забываем о том, что нумерация с 0)
print(list_2[-1])  # обратились к последнему элементу списка и вывели его
print(list_2[2:-3])  # вывели срез списка с 3 элемента (нумерация с 0) до -3 элемента, но без -3
print(list_2[-2:3:-1])  # взяли срез с обратным шагом
# (можно по-другому: list_2[4:-1:1]; объясните, почему именно такие параметры необходимо выбрать, чтобы вывелось то же самое)

list_1_and_2 = [list_1, list_2] # создали список списков, ОБЯЗАТЕЛЬНО ПОСМОТРИТЕ ПРИМЕР ВНИЗУ
print(list_1_and_2[1][3]) # обратились к 4 элементу списка list_2
list_1[0] = "f" # изменили первый элемент списка на "f"
list_3 = list_1 + list_2  # совместили два списка в один (как склеить строки, но только списки)))


length = len(list_3) # узнали длинну списка
print(min(list_3))  # вывели минимальный элемент списка (по тому же принципу max(list_3) вернет максимальный, sum(list_3) сумму )
list_3.index("b") # узнали номер элемента равного "b" (не забудьте, что индекс с 0)
list_4 = list_3.copy() # скопировали список в другую переменную (обязательно посмотрите пример ниже)
count_of_d = list_4.count("d") # узнали, сколько раз элемент встречается в списке


list_3.remove("d") # удалили элемент "d" (ничего нам не вернется)
element_four = list_3.pop(4) # извлекли элемент номер 4 и положили в другую переменную, но в изначальном списке удалили
del list_3[3] # удалили элемент номер 4

list_3.sort()  # сортировка по алфавиту
list_3.clear()  # удалит весь список (сделает его пустым)

''''  Почему нельзя просто написать list_1 = list_2
А необходимо использовать list_1 = list_2.copy()'''
list_1 = list_2
print(list_1)
list_2[0] = 56
print(list_1)
''''Мы вроде изменили второй список, но и значения и в первом поменялись, в обратную сторону это тоже работает
 Мы их как бы сделали не просто близнецами а сиамскими близнецами, что бы ни случилось с одним, произойдет и с другим
Это происходит из-за того, что мы указали ссылку на существующую ячейку памяти, а не создали новую.
Это работает только со списками и некоторыми другими структурами ) 
Но вот если мы используем оператор +, как было выше, то все в порядке 
Так же это работает и для list_1_and_2 = [list_1, list_2]: при изменении list_1 будет меняться и list_1_and_2'''